
# ===========================================
#   Unified Flow Test File: all.flow
#   For testing flow.c end-to-end
# ===========================================


# Test Case 1: Simple two-component cycle
# pipe1 depends on pipe2, pipe2 depends on pipe1

node=echo_hello
command=echo "hello"

pipe=pipe1
from=pipe2
to=echo_hello

pipe=pipe2
from=pipe1
to=echo_hello

# Test Case 2: Self-referencing pipe (direct self-cycle)

pipe=self_cycle
from=self_cycle
to=echo_hello

# Test Case 3: Three-component cycle
# cycle_a → cycle_b → cycle_c → cycle_a

node=cat_something
command=cat foo.txt

pipe=cycle_a
from=cycle_c
to=cat_something

pipe=cycle_b
from=cycle_a
to=cat_something

pipe=cycle_c
from=cycle_b
to=cat_something

# Test Case 4: Cycle through concatenate
# concat depends on pipe_x, which depends on concat

concatenate=concat_cycle
parts=2
part_0=echo_hello
part_1=pipe_x

pipe=pipe_x
from=concat_cycle
to=cat_something

# Test Case 5: Complex nested cycle
# This creates a more complex dependency graph with a cycle

node=ls_command
command=ls

node=wc_command
command=wc

pipe=complex_1
from=ls_command
to=complex_2

pipe=complex_2
from=complex_3
to=wc_command

pipe=complex_3
from=complex_1
to=wc_command

# Test Case 6: Cycle through stderr redirect

node=mkdir_test
command=mkdir test_dir

stderr=stderr_redirect
from=pipe_with_stderr

pipe=pipe_with_stderr
from=stderr_redirect

# Test Case 7: Valid case (no cycle) - for comparison
# This should work fine when called

node=valid_ls
command=ls -la

node=valid_wc
command=wc -l

pipe=valid_pipe
from=valid_ls
to=valid_wc



# ---------- Test 1: Basic Pipe (ls | wc)
node=list_files
command=ls

node=word_count
command=wc

pipe=basic_pipe
from=list_files
to=word_count


# ---------- Test 2: Concatenation (cat foo.txt ; cat foo.txt | sed 's/o/u/g' ) | wc
node=cat_foo
command=cat foo.txt

node=sed_o_u
command=sed 's/o/u/g'

pipe=foo_to_fuu
from=cat_foo
to=sed_o_u

concatenate=foo_then_fuu
parts=2
part_0=cat_foo
part_1=foo_to_fuu

node=word_count_concat
command=wc

pipe=concat_test
from=foo_then_fuu
to=word_count_concat


# ---------- Test 3: stderr redirection (cat a |& wc)
node=cat
command=cat a

node=word_count_err
command=wc

stderr=stderr_pipe
from=cat

pipe=stderr_test
from=stderr_pipe
to=word_count_err



# ---------- Test 4: File input example (cat < file | wc)
file=input_file
name=foo.txt

node=cat_file
command=cat

node=word_count_file
command=wc

pipe=read_pipe
from=input_file
to=cat_file

pipe=file_pipe_test
from=read_pipe
to=word_count_file


# ---------- Test 5: Chained pipes (ls | grep txt | wc)
node=list_files_chain
command=ls

node=grep_txt
command=grep txt

node=word_count_chain
command=wc

pipe=chained_pipe
from=list_files_chain
to=grep_txt



# ---------- Test 6: Parallel pipes (cat foo.txt | grep foo) & (cat foo.txt | grep bar)
node=cat_file_parallel
command=cat foo.txt

node=grep_foo
command=grep foo

node=grep_bar
command=grep bar

pipe=parallel_foo
from=cat_file_parallel
to=grep_foo

pipe=parallel_bar
from=cat_file_parallel
to=grep_bar


# ---------- Test 7: Empty input (cat empty.txt | wc)
node=cat_empty
command=cat empty.txt

node=word_count_empty
command=wc

pipe=empty_input
from=cat_empty
to=word_count_empty


# ---------- Test 8: Circular reference (invalid)
node=a
command=cat foo.txt

node=b
command=wc

pipe=cycle1
from=a
to=b

pipe=circular_pipe
from=cycle1
to=a


# ---------- Test 9: Missing command (invalid)
node=foo
pipe=bad_pipe
from=foo
to=bar


